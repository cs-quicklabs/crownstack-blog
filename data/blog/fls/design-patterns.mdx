---
title: 'Design Patterns'
date: 2023-05-25T15:32:14Z
lastmod: '2023-05-25'
tags: ['engineering', 'training', 'clean code', 'fls']
draft: false
summary: 'Learn the most common software design patterns.'
layout: PostSimple
authors: ['aashish-dhawan']
---

# Software Design Patterns

**Design patterns**

are typical solutions to common problems in software design. Each pattern is like a blueprint that you can customize to solve a particular design problem in your code.

### **Creational patterns**

These patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.

**[Factory Method](https://refactoring.guru/design-patterns/factory-method)**
Provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.
[](https://refactoring.guru/design-patterns/factory-method)

**[Abstract Factory](https://refactoring.guru/design-patterns/abstract-factory)**
Lets you produce families of related objects without specifying their concrete classes.
[](https://refactoring.guru/design-patterns/abstract-factory)

**[Builder](https://refactoring.guru/design-patterns/builder)**
Lets you construct complex objects set by step. This pattern allows you to produce different types of representations of an object using the same construction code.
[](https://refactoring.guru/design-patterns/builder)

**[Prototype](https://refactoring.guru/design-patterns/prototype)**
Lets you copy existing objects without making your code dependent on their classes
[](https://refactoring.guru/design-patterns/prototype)

**[Singleton](https://refactoring.guru/design-patterns/singleton)**
Lets you ensure that a class has only one instance, while providing a global access point to this instance
[](https://refactoring.guru/design-patterns/singleton)

### **Structural patterns**

These patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient.

**[Adapter](https://refactoring.guru/design-patterns/adapter)**
Allows objects with incompatible interfaces to collaborate

**[Bridge](https://refactoring.guru/design-patterns/bridge)**
Lets you split a large class or a set of closely related classes into two separate hierarchies - abstraction and implementation - which can be deployed independently of each other
[](https://refactoring.guru/design-patterns/bridge)

**[Composite](https://refactoring.guru/design-patterns/composite)**
Lets you compose into tree structures and then work with these structures as if they were individual parts
[](https://refactoring.guru/design-patterns/composite)

**[Decorator](https://refactoring.guru/design-patterns/decorator)**
Lets you attach new behaviors to objects by placing these objects into special wrapper objects that contain these behaviors
[](https://refactoring.guru/design-patterns/decorator)

**[Facade](https://refactoring.guru/design-patterns/facade)**
Provides a simplified interface to a library, a framework or any other complex set of classes.
[](https://refactoring.guru/design-patterns/facade)

**[Flyweight](https://refactoring.guru/design-patterns/flyweight)**
Lets you fit more objects into the available amount of RAM by sharing common part of state between multiple objects instead of keeping all of the data in each object.
[](https://refactoring.guru/design-patterns/flyweight)

**[Proxy](https://refactoring.guru/design-patterns/proxy)**
Lets you provide a substitute or a placeholder for another object. A proxy controls access to original object, allowing you to perform something either before or after the request gets through the original object.
[](https://refactoring.guru/design-patterns/proxy)

### **Behavioral patterns**

These patterns are concerned with algorithms and the assignment of responsibilities between objects.

**[Chain of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility)**
Lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.

**[Command](https://refactoring.guru/design-patterns/command)**
Turns a request into a stand-alone object that contains all information about the request. This transformation lets you pass requests as a method arguments, delay or queue a request's execution, and support undoable operations.

**[Iterator](https://refactoring.guru/design-patterns/iterator)**
Lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.).

**[Mediator](https://refactoring.guru/design-patterns/mediator)**
Lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.

**[Memento](https://refactoring.guru/design-patterns/memento)**
Lets you save and restore the previous state of an object without revealing the details of its implementation.

**[Observer](https://refactoring.guru/design-patterns/observer)**
Lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they're observing.

**[State](https://refactoring.guru/design-patterns/state)**
Lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.

**[Strategy](https://refactoring.guru/design-patterns/strategy)**
Lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.

**[Template Method](https://refactoring.guru/design-patterns/template-method)**
Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.

**[Visitor](https://refactoring.guru/design-patterns/visitor)**
Lets you separate algorithms from the objects on which they operate.

## References and Credit

1. [Refactoring Guru](https://refactoring.guru/)
